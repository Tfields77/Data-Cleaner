# -*- coding: utf-8 -*-
"""datacleaner.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bp5J6pGnBPxwqW-cFWn8XX9KJPk-ocSJ
"""

import pandas as pd
import numpy as np
import re

# Step 1: Define Data Cleaning Functions
class DataCleaner:
    def __init__(self, dataframe):
        self.dataframe = dataframe

    def remove_duplicates(self):
        self.dataframe = self.dataframe.drop_duplicates()
        return self.dataframe

    def handle_missing_values(self, strategy='mean'):
        if strategy == 'mean':
            self.dataframe = self.dataframe.fillna(self.dataframe.select_dtypes(include=[np.number]).mean())
        elif strategy == 'median':
            self.dataframe = self.dataframe.fillna(self.dataframe.select_dtypes(include=[np.number]).median())
        elif strategy == 'mode':
            self.dataframe = self.dataframe.fillna(self.dataframe.select_dtypes(include=[np.number]).mode().iloc[0])
        elif strategy == 'drop':
            self.dataframe = self.dataframe.dropna()
        return self.dataframe

    def normalize_data(self):
        numeric_cols = self.dataframe.select_dtypes(include=[np.number]).columns
        self.dataframe[numeric_cols] = (self.dataframe[numeric_cols] - self.dataframe[numeric_cols].min()) / (self.dataframe[numeric_cols].max() - self.dataframe[numeric_cols].min())
        return self.dataframe

    def standardize_data(self):
        numeric_cols = self.dataframe.select_dtypes(include=[np.number]).columns
        self.dataframe[numeric_cols] = (self.dataframe[numeric_cols] - self.dataframe[numeric_cols].mean()) / self.dataframe[numeric_cols].std()
        return self.dataframe

    def remove_outliers_zscore(self, threshold=3):
        numeric_cols = self.dataframe.select_dtypes(include=[np.number]).columns
        z_scores = np.abs((self.dataframe[numeric_cols] - self.dataframe[numeric_cols].mean()) / self.dataframe[numeric_cols].std())
        self.dataframe = self.dataframe[(z_scores < threshold).all(axis=1)]
        return self.dataframe

    def remove_outliers_iqr(self):
        Q1 = self.dataframe.quantile(0.25)
        Q3 = self.dataframe.quantile(0.75)
        IQR = Q3 - Q1
        self.dataframe = self.dataframe[~((self.dataframe < (Q1 - 1.5 * IQR)) | (self.dataframe > (Q3 + 1.5 * IQR))).any(axis=1)]
        return self.dataframe

    def convert_to_datetime(self, column):
        try:
            self.dataframe[column] = pd.to_datetime(self.dataframe[column])
        except Exception as e:
            print(f"Error converting {column} to datetime: {e}")
        return self.dataframe

    def convert_to_category(self, column):
        try:
            self.dataframe[column] = self.dataframe[column].astype('category')
        except Exception as e:
            print(f"Error converting {column} to category: {e}")
        return self.dataframe

    def convert_to_numeric(self, column):
        try:
            self.dataframe[column] = pd.to_numeric(self.dataframe[column], errors='coerce')
        except Exception as e:
            print(f"Error converting {column} to numeric: {e}")
        return self.dataframe

    def drop_columns(self, columns):
        self.dataframe = self.dataframe.drop(columns, axis=1)
        return self.dataframe

    def rename_column(self, old_name, new_name):
        self.dataframe = self.dataframe.rename(columns={old_name: new_name})
        return self.dataframe

    def filter_rows(self, condition):
        try:
            self.dataframe = self.dataframe.query(condition)
        except Exception as e:
            print(f"Error filtering rows with condition '{condition}': {e}")
        return self.dataframe

    def fill_column_with_value(self, column, value):
        self.dataframe[column] = self.dataframe[column].fillna(value)
        return self.dataframe

    def lowercase_column(self, column):
        self.dataframe[column] = self.dataframe[column].str.lower()
        return self.dataframe

    def uppercase_column(self, column):
        self.dataframe[column] = self.dataframe[column].str.upper()
        return self.dataframe

    def trim_whitespace(self, column):
        self.dataframe[column] = self.dataframe[column].str.strip()
        return self.dataframe

    def replace_values(self, column, to_replace, value):
        self.dataframe[column] = self.dataframe[column].replace(to_replace, value)
        return self.dataframe

    def drop_na(self, axis=0):
        self.dataframe = self.dataframe.dropna(axis=axis)
        return self.dataframe

    def dropna_in_column(self, column):
        self.dataframe = self.dataframe.dropna(subset=[column])
        return self.dataframe

    def sample_data(self, frac=0.1):
        self.dataframe = self.dataframe.sample(frac=frac)
        return self.dataframe

    def describe_data(self):
        return self.dataframe.describe()

    def get_dataframe(self):
        return self.dataframe

    def show_null_values(self):
        return self.dataframe.isnull().sum()

    def aggregate_column(self, column, agg_func='sum'):
        if agg_func == 'sum':
            return self.dataframe[column].sum()
        elif agg_func == 'mean':
            return self.dataframe[column].mean()
        elif agg_func == 'max':
            return self.dataframe[column].max()
        elif agg_func == 'min':
            return self.dataframe[column].min()
        elif agg_func == 'count':
            return self.dataframe[column].count()
        else:
            return f"Aggregation function '{agg_func}' not recognized."

    def merge_dataframes(self, other_dataframe, on_column):
        self.dataframe = self.dataframe.merge(other_dataframe, on=on_column)
        return self.dataframe

# Step 2: Define the NLP Component for Command Interpretation
class CommandInterpreter:
    def interpret(self, command):
        command = command.lower()
        if 'remove duplicates' in command:
            return ('remove_duplicates',)
        elif 'handle missing values' in command:
            strategy = 'mean'  # Default strategy
            if 'mean' in command:
                strategy = 'mean'
            elif 'median' in command:
                strategy = 'median'
            elif 'mode' in command:
                strategy = 'mode'
            elif 'drop' in command:
                strategy = 'drop'
            return ('handle_missing_values', strategy)
        elif 'normalize' in command:
            return ('normalize_data',)
        elif 'standardize' in command:
            return ('standardize_data',)
        elif 'remove outliers' in command:
            if 'zscore' in command or 'z-score' in command:
                return ('remove_outliers_zscore',)
            elif 'iqr' in command:
                return ('remove_outliers_iqr',)
        elif 'convert to datetime' in command:
            column = re.search(r'convert to datetime (.+)', command).group(1)
            return ('convert_to_datetime', column)
        elif 'convert to category' in command:
            column = re.search(r'convert to category (.+)', command).group(1)
            return ('convert_to_category', column)
        elif 'convert to numeric' in command:
            column = re.search(r'convert to numeric (.+)', command).group(1)
            return ('convert_to_numeric', column)
        elif 'drop columns' in command:
            columns = re.search(r'drop columns (.+)', command).group(1).split(',')
            return ('drop_columns', columns)
        elif 'rename column' in command:
            old_name, new_name = re.search(r'rename column (.+) to (.+)', command).groups()
            return ('rename_column', old_name, new_name)
        elif 'filter rows' in command:
            condition = re.search(r'filter rows (.+)', command).group(1)
            return ('filter_rows', condition)
        elif 'fill column with value' in command:
            column, value = re.search(r'fill column (.+) with value (.+)', command).groups()
            return ('fill_column_with_value', column, value)
        elif 'lowercase column' in command:
            column = re.search(r'lowercase column (.+)', command).group(1)
            return ('lowercase_column', column)
        elif 'uppercase column' in command:
            column = re.search(r'uppercase column (.+)', command).group(1)
            return ('uppercase_column', column)
        elif 'trim whitespace' in command:
            column = re.search(r'trim whitespace from column (.+)', command).group(1)
            return ('trim_whitespace', column)
        elif 'replace values' in command:
            column, to_replace, value = re.search(r'replace values in column (.+) from (.+) to (.+)', command).groups()
            return ('replace_values', column, to_replace, value)
        elif 'drop na' in command:
            axis = 0 if 'rows' in command else 1
            return ('drop_na', axis)
        elif 'drop na in column' in command:
            column = re.search(r'drop na in column (.+)', command).group(1)
            return ('dropna_in_column', column)
        elif 'sample data' in command:
            frac = float(re.search(r'sample data (\d+\.?\d*)', command).group(1))
            return ('sample_data', frac)
        elif 'describe data' in command:
            return ('describe_data',)
        elif 'show null values' in command:
            return ('show_null_values',)
        elif 'aggregate column' in command:
            column, agg_func = re.search(r'aggregate column (.+) using (.+)', command).groups()
            return ('aggregate_column', column, agg_func)
        elif 'merge dataframes' in command:
            other_file, on_column = re.search(r'merge dataframes with (.+) on (.+)', command).groups()
            return ('merge_dataframes', other_file, on_column)
        else:
            return ('unknown_command',)

# Step 3: Execute the Commands on the DataFrame
def execute_commands(dataframe, commands):
    cleaner = DataCleaner(dataframe)
    interpreter = CommandInterpreter()

    for command in commands:
        result = interpreter.interpret(command)
        if result[0] == 'unknown_command':
            print(f"Unknown command: {command}")
            continue

        func = getattr(cleaner, result[0])
        if len(result) > 1:
            dataframe = func(*result[1:])
        else:
            dataframe = func()

    return cleaner.get_dataframe()

# Example usage with a sample dataframe and commands
df = pd.DataFrame({
    'A': [1, 2, 3, 4, 5],
    'B': [5, 4, 3, 2, 1],
    'C': ['2021-01-01', '2021-02-01', '2021-03-01', '2021-04-01', '2021-05-01']
})

# Interactive command input
commands = []
while True:
    command = input("Enter a command (or 'done' to finish): ")
    if command.lower() == 'done':
        break
    commands.append(command)

# Process the commands
cleaned_df = execute_commands(df, commands)
print(cleaned_df)

